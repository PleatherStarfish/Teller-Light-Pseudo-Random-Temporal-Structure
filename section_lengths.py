
# coding: utf-8

# <h1><i>Teller Light</i></h1>
# <h2>Pseudo-Random Temporal Structure</h2>
#
# The purpose of this program is to pseudo-randomly generate the section lengths and subsection lengths for my composition <i>Teller Light</i> (2017) which is highlighted in my masters thesis for Dartmouth college, "Are Scores Maps? A Wayfinding Approach to Music Notation." The output of this program is formatted for use in a Max/MSP "coll object. For each performance of <i>Teller Light</i>, the Max patch should be loaded with a .txt file generated by this Python script.

# In[1]:


import random
import numpy as np
from random import randint
from random import shuffle
from scipy.interpolate import interp1d
import itertools


## Use this variable to set whether section lengths are represented as min. [1], sec. [60], or ms. [60000]
## -----------------------------
sec_min = 60000
## -----------------------------


## Use this variable to set the approx. duration of the piece.
## -----------------------------
sizelimit = 30*sec_min
## -----------------------------


## Converts a list of section durations to a list of time points for the start time of each section (starting with 0)
## ---------------------------------------------------------------------------------------
def legthsToTimePoints(input_list):
    attack_points_list = []
    summing_loop_list = []

    attack_points_list.append(0)

    for item in input_list:
        summing_loop_list.append(item)
        attack_points_list.append(sum(summing_loop_list))

    return attack_points_list
## ---------------------------------------------------------------------------------------



## This code is from SilentGhost at http://stackoverflow.com/q/2400840
## ---------------------------------------------------------------------------------------
def timePointsToLengths(input_list):
    return [j-i for i, j in zip(input_list[:-1], input_list[1:])]
## ---------------------------------------------------------------------------------------



## We want some variation in section start and end times; hence this function
## ---------------------------------------------------------------------------------------
def randomizeSectionLengths(start_times, durations):
    output_list = []
    for onset, length in zip(start_times, durations):
        if  (onset == 0):
            output_list.append(0)
        elif (length > 2*sec_min):
            output_list.append(onset + (random.uniform(-1.5*sec_min, 1.5*sec_min)))
        else:
            output_list.append(onset + (random.uniform(0, 1.5*sec_min)))

    output_list2 = []
    for new_onset, old_onset  in zip(output_list, start_times):
        if (randint(0,9) < 6):
            output_list2.append(old_onset)
        else:
            output_list2.append(new_onset)

    return output_list2
## ---------------------------------------------------------------------------------------



## Now we make the small subsections between each large section timepoint
## ---------------------------------------------------------------------------------------
def parseForColl(large_section_time_points, large_section_lengths, count):
    index_counter = 0
    subsection_list = []
    for time_point, length in zip(large_section_time_points, large_section_lengths):       ## first we iterate over both lists
        subsection = []
        while (sum(subsection) < length):
            subsection.append(random.uniform(1., (random.uniform(2.*sec_min,4.*sec_min)))) ## fill sections with subsections
        interped = interp1d([0.0,(sum(subsection))],[0.0,length])                          ## scale subsections to match lengths

        subsection_lengths = interped(subsection)
        subsection_time_points = legthsToTimePoints(subsection_lengths)

        subsection_lengths = [ round(elem, 4) for elem in subsection_lengths ]
        subsection_time_points = [ round(elem, 4) for elem in subsection_time_points ]

        count = (count + 1) % 2
        if (count == 1):
            quality = "HARMONICS"
        else:
            quality = "SILENCE"

        print index_counter, ",", time_point, length, quality, ";"
        index_counter += 1

        for sublengths, sub_time_points in zip(subsection_lengths, subsection_time_points):

            print index_counter, ",", sub_time_points+time_point, sublengths, "subsection", ";"
            index_counter += 1
        ##subsection_list.extend(subsection_time_points)
    ##print subsection_list
## ---------------------------------------------------------------------------------------



## Now we make the small subsections between each large section timepoint
## ---------------------------------------------------------------------------------------
def parseForColl2(large_section_time_points, large_section_lengths, count):
    index_counter = 0
    subsection_list = []
    for time_point, length in zip(large_section_time_points, large_section_lengths):       ## first we iterate over both lists
        subsection = []
        while (sum(subsection) < length):
            subsection.append(random.uniform(1., (random.uniform(2.*sec_min,4.*sec_min)))) ## fill sections with subsections
        interped = interp1d([0.0,(sum(subsection))],[0.0,length])                          ## scale subsections to match lengths

        subsection_lengths = interped(subsection)
        subsection_time_points = legthsToTimePoints(subsection_lengths)

        subsection_lengths = [ round(elem, 4) for elem in subsection_lengths ]
        subsection_time_points = [ round(elem, 4) for elem in subsection_time_points ]

        count = (count + 1) % 2
        if (count == 1):
            quality = "HARMONICS"
            quality2 = "harmonics"
        else:
            quality = "SILENCE"
            quality2 = "silence"

        ##print index_counter, ",", time_point, length, quality, ";"
        ##index_counter += 1

        for sublengths, sub_time_points in zip(subsection_lengths, subsection_time_points):

            print index_counter, ",", sub_time_points+time_point, sublengths, quality2, ";"
            index_counter += 1
    print index_counter, ",", sum(large_section_lengths), "0.0", "end", ";"
        ##subsection_list.extend(subsection_time_points)
    ##print subsection_list
## ---------------------------------------------------------------------------------------


# <h2>Global Section Lengths</h2>
#
# Now we create the large section lengths in abstract. Note that later the start and end times of these sections will be slightly randomized for each instrument. At the moment all we are doing is creating the global section lengths.
#
# If you change the "sec_min" variable above, remember to rerun the first cell again before running this cell.

# In[ ]:


large_sections = []  ## A list on which to append the large sections values

## Here we create one large section between 12. and 15.
large_sections.append(random.uniform(12.*sec_min, 15.*sec_min))

## Now fill up the rest of the time with sections between 1.5 and 7.
while (sum(large_sections) < sizelimit):
    large_sections.append(random.uniform(1.5*sec_min, 7.*sec_min))

## suffle the order of the sections
random.shuffle(large_sections)

## Changing the variable names to make it more clear
large_section_lengths = large_sections
large_section_time_points = legthsToTimePoints(large_sections)

## What is the index of the longest LARGE section?
count = large_section_lengths.index(max(large_section_lengths)) % 2

print "LARGE SECTION LENGTHS: ", "[sum = ", str(sum(large_section_lengths))+"]"
print large_section_lengths
print " "
print "LARGE SECTION TIME POINTS:"
print large_section_time_points


# <h3>The following code (from https://plot.ly/python/horizontal-bar-charts/) is used to visualize the large sections of <i>Teller Light</i> for debugging.</h3>

# <h3>A new variable unique to each instrument is set to the value of "large_section_lengths." Start times of the large sections are randomized, and the durations of each section are recalculated for each instrument individually.</h3>

# In[ ]:


##print large_section_lengths
##print " "

large_section_lengths_vn = large_section_lengths
large_section_lengths_va = large_section_lengths
large_section_lengths_vc = large_section_lengths

##print large_section_lengths_vn
##print large_section_lengths_va
##print large_section_lengths_vc
##print " "

large_section_time_points_vn = legthsToTimePoints(large_section_lengths_vn)
large_section_time_points_va = legthsToTimePoints(large_section_lengths_va)
large_section_time_points_vc = legthsToTimePoints(large_section_lengths_vc)

##print large_section_time_points_vn
##print large_section_time_points_va
##print large_section_time_points_vc
##print " "

## Randomize onset times list
large_section_time_points_vn = randomizeSectionLengths(large_section_time_points_vn, large_section_lengths_vn)
large_section_time_points_va = randomizeSectionLengths(large_section_time_points_va, large_section_lengths_va)
large_section_time_points_vc = randomizeSectionLengths(large_section_time_points_vc, large_section_lengths_vc)

## Round points off to four digits
large_section_time_points_vn = [ round(elem, 4) for elem in large_section_time_points_vn ]
large_section_time_points_va = [ round(elem, 4) for elem in large_section_time_points_va ]
large_section_time_points_vc = [ round(elem, 4) for elem in large_section_time_points_vc ]

print "TIME POINTS:"
print large_section_time_points_vn
print large_section_time_points_va
print large_section_time_points_vc

large_section_lengths_vn = timePointsToLengths(large_section_time_points_vn)
large_section_lengths_va = timePointsToLengths(large_section_time_points_va)
large_section_lengths_vc = timePointsToLengths(large_section_time_points_vc)

large_section_lengths_vn = [ round(elem, 4) for elem in large_section_lengths_vn ]
large_section_lengths_va = [ round(elem, 4) for elem in large_section_lengths_va ]
large_section_lengths_vc = [ round(elem, 4) for elem in large_section_lengths_vc ]


print " "
print "LENGTHS"
print large_section_lengths_vn
print large_section_lengths_va
print large_section_lengths_vc


# In[ ]:


print "VIOLIN SECTIONS FORMATED FOR MAX COLL: index, start_time section_length type;"
print " "
print parseForColl(large_section_time_points_vn, large_section_lengths_vn, count)
print " "
print " "
print "VIOLA SECTIONS FORMATED FOR MAX COLL: index, start_time section_length type;"
print " "
print parseForColl(large_section_time_points_va, large_section_lengths_vc, count)
print " "
print " "
print "CELLO SECTIONS FORMATED FOR MAX COLL: index, start_time section_length type;"
print " "
print parseForColl(large_section_time_points_vc, large_section_lengths_vc, count)


# In[ ]:


print "VIOLIN SECTIONS FORMATED FOR MAX COLL: index, start_time section_length type;"
print " "
print parseForColl2(large_section_time_points_vn, large_section_lengths_vn, count)
print " "
print " "
print "VIOLA SECTIONS FORMATED FOR MAX COLL: index, start_time section_length type;"
print " "
print parseForColl2(large_section_time_points_va, large_section_lengths_vc, count)
print " "
print " "
print "CELLO SECTIONS FORMATED FOR MAX COLL: index, start_time section_length type;"
print " "
print parseForColl2(large_section_time_points_vc, large_section_lengths_vc, count)
